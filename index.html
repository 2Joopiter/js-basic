<!DOCTYPE html>
<html lang='ko'>

<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>Document</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <script>
    /*
    원시형 자료 vs 참조형 자료
      -원시형자료: 메모리에 물리적으로 해당 값이 담기는 자료형
        --메모리에 값만 담김
        --값의 크기가 비교적 명확
        --메모리 선언과 원시형 자료값 할당이 모두 callstack에서 이루어짐
        --문자열, 숫자, 논리형자료, undefined (string, number, boolean, undefined)



      -참조형자료: 메모리에 해당값 자체가 아닌 해당값의 위치값이 참조되는 자료형
        --메모리에 해당 값의 위치값만 참조되는 것이 아닌 해당 값으로 활용할 수 있는 여러가지 메서드(등록된 함수)도 같이 참조됨
        --값의 크기를 구체적으로 산정하기 어려움 (가변적인 값이거나..)
        --메모리선언은 callstack에서 일어났지만 실제 값은 힙메모리에 저장되므로 힙메모리의 위치값만 callstack 변수에 참조됨
        --배열, 객체, null (array, object, null)

        const는 재할당이 불가능

      */


    /*
  //const data = 'game'
  //data = 3;
  //console.log(data);

  // 이미 물리적인 값이 있는 상황이라서 불가능. 변경하려면 재할당이 일어나기 때문에.
  // 실제로 data 메모리 공간에 'game'이라는 원시형 자료값이 물리적으로 들어있어서 변경 X



  const colors = ['red', 'blue', 'yellow'];
   //해당 참조링크는 동일한 상태. 참조 링크가 가리키고 있는 1번째 값을 변경하는 것.
   // callstack에 있는 colors 변수에 참조링크가 변경되는 것은 아님. 참조형자료만 변하는 것. 
   // 기본 구조를 유지하고 있으면 값의 추가나 제거, 변경이 가능
   // colors는 call stack에 있고, 뒤의 값들은 heap memory에 있기 때문에 변경 가능
  colors[0] = 'hotpink';
   // 그래서 변경이 가능해짐
  console.log(colors);

  colors = [1,2,3];
   // 이렇게 새롭게 값을 재할당 하려고 하면 변수의 구조가 바뀌기 때문에 (새로운 참조링크가 할당) 에러발생

  // 위치 정보 자체는 바뀌지 않았기 때문에 안의 데이터는 변경이 가능
  // Colors라는 메모리에는 callstack의 배열값 자체가 담기는 게 아닌 heap memory 안의 위치값만 참조되는 것. 

  */


  </script>
</body>

</html>